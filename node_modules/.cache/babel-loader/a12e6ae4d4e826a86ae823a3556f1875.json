{"ast":null,"code":"'use strict';\n\nmodule.exports = Point;\n/**\n * A standalone point geometry with useful accessor, comparison, and\n * modification methods.\n *\n * @class Point\n * @param {Number} x the x-coordinate. this could be longitude or screen\n * pixels, or any other sort of unit.\n * @param {Number} y the y-coordinate. this could be latitude or screen\n * pixels, or any other sort of unit.\n * @example\n * var point = new Point(-77, 38);\n */\n\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype = {\n  /**\n   * Clone this point, returning a new point that can be modified\n   * without affecting the old one.\n   * @return {Point} the clone\n   */\n  clone: function () {\n    return new Point(this.x, this.y);\n  },\n\n  /**\n   * Add this point's x & y coordinates to another point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  add: function (p) {\n    return this.clone()._add(p);\n  },\n\n  /**\n   * Subtract this point's x & y coordinates to from point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  sub: function (p) {\n    return this.clone()._sub(p);\n  },\n\n  /**\n   * Multiply this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  multByPoint: function (p) {\n    return this.clone()._multByPoint(p);\n  },\n\n  /**\n   * Divide this point's x & y coordinates by point,\n   * yielding a new point.\n   * @param {Point} p the other point\n   * @return {Point} output point\n   */\n  divByPoint: function (p) {\n    return this.clone()._divByPoint(p);\n  },\n\n  /**\n   * Multiply this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {Point} k factor\n   * @return {Point} output point\n   */\n  mult: function (k) {\n    return this.clone()._mult(k);\n  },\n\n  /**\n   * Divide this point's x & y coordinates by a factor,\n   * yielding a new point.\n   * @param {Point} k factor\n   * @return {Point} output point\n   */\n  div: function (k) {\n    return this.clone()._div(k);\n  },\n\n  /**\n   * Rotate this point around the 0, 0 origin by an angle a,\n   * given in radians\n   * @param {Number} a angle to rotate around, in radians\n   * @return {Point} output point\n   */\n  rotate: function (a) {\n    return this.clone()._rotate(a);\n  },\n\n  /**\n   * Rotate this point around p point by an angle a,\n   * given in radians\n   * @param {Number} a angle to rotate around, in radians\n   * @param {Point} p Point to rotate around\n   * @return {Point} output point\n   */\n  rotateAround: function (a, p) {\n    return this.clone()._rotateAround(a, p);\n  },\n\n  /**\n   * Multiply this point by a 4x1 transformation matrix\n   * @param {Array<Number>} m transformation matrix\n   * @return {Point} output point\n   */\n  matMult: function (m) {\n    return this.clone()._matMult(m);\n  },\n\n  /**\n   * Calculate this point but as a unit vector from 0, 0, meaning\n   * that the distance from the resulting point to the 0, 0\n   * coordinate will be equal to 1 and the angle from the resulting\n   * point to the 0, 0 coordinate will be the same as before.\n   * @return {Point} unit vector point\n   */\n  unit: function () {\n    return this.clone()._unit();\n  },\n\n  /**\n   * Compute a perpendicular point, where the new y coordinate\n   * is the old x coordinate and the new x coordinate is the old y\n   * coordinate multiplied by -1\n   * @return {Point} perpendicular point\n   */\n  perp: function () {\n    return this.clone()._perp();\n  },\n\n  /**\n   * Return a version of this point with the x & y coordinates\n   * rounded to integers.\n   * @return {Point} rounded point\n   */\n  round: function () {\n    return this.clone()._round();\n  },\n\n  /**\n   * Return the magitude of this point: this is the Euclidean\n   * distance from the 0, 0 coordinate to this point's x and y\n   * coordinates.\n   * @return {Number} magnitude\n   */\n  mag: function () {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  },\n\n  /**\n   * Judge whether this point is equal to another point, returning\n   * true or false.\n   * @param {Point} other the other point\n   * @return {boolean} whether the points are equal\n   */\n  equals: function (other) {\n    return this.x === other.x && this.y === other.y;\n  },\n\n  /**\n   * Calculate the distance from this point to another point\n   * @param {Point} p the other point\n   * @return {Number} distance\n   */\n  dist: function (p) {\n    return Math.sqrt(this.distSqr(p));\n  },\n\n  /**\n   * Calculate the distance from this point to another point,\n   * without the square root step. Useful if you're comparing\n   * relative distances.\n   * @param {Point} p the other point\n   * @return {Number} distance\n   */\n  distSqr: function (p) {\n    var dx = p.x - this.x,\n        dy = p.y - this.y;\n    return dx * dx + dy * dy;\n  },\n\n  /**\n   * Get the angle from the 0, 0 coordinate to this point, in radians\n   * coordinates.\n   * @return {Number} angle\n   */\n  angle: function () {\n    return Math.atan2(this.y, this.x);\n  },\n\n  /**\n   * Get the angle from this point to another point, in radians\n   * @param {Point} b the other point\n   * @return {Number} angle\n   */\n  angleTo: function (b) {\n    return Math.atan2(this.y - b.y, this.x - b.x);\n  },\n\n  /**\n   * Get the angle between this point and another point, in radians\n   * @param {Point} b the other point\n   * @return {Number} angle\n   */\n  angleWith: function (b) {\n    return this.angleWithSep(b.x, b.y);\n  },\n\n  /*\n   * Find the angle of the two vectors, solving the formula for\n   * the cross product a x b = |a||b|sin(θ) for θ.\n   * @param {Number} x the x-coordinate\n   * @param {Number} y the y-coordinate\n   * @return {Number} the angle in radians\n   */\n  angleWithSep: function (x, y) {\n    return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);\n  },\n  _matMult: function (m) {\n    var x = m[0] * this.x + m[1] * this.y,\n        y = m[2] * this.x + m[3] * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n  _add: function (p) {\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  },\n  _sub: function (p) {\n    this.x -= p.x;\n    this.y -= p.y;\n    return this;\n  },\n  _mult: function (k) {\n    this.x *= k;\n    this.y *= k;\n    return this;\n  },\n  _div: function (k) {\n    this.x /= k;\n    this.y /= k;\n    return this;\n  },\n  _multByPoint: function (p) {\n    this.x *= p.x;\n    this.y *= p.y;\n    return this;\n  },\n  _divByPoint: function (p) {\n    this.x /= p.x;\n    this.y /= p.y;\n    return this;\n  },\n  _unit: function () {\n    this._div(this.mag());\n\n    return this;\n  },\n  _perp: function () {\n    var y = this.y;\n    this.y = this.x;\n    this.x = -y;\n    return this;\n  },\n  _rotate: function (angle) {\n    var cos = Math.cos(angle),\n        sin = Math.sin(angle),\n        x = cos * this.x - sin * this.y,\n        y = sin * this.x + cos * this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n  _rotateAround: function (angle, p) {\n    var cos = Math.cos(angle),\n        sin = Math.sin(angle),\n        x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),\n        y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n    this.x = x;\n    this.y = y;\n    return this;\n  },\n  _round: function () {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  }\n};\n/**\n * Construct a point from an array if necessary, otherwise if the input\n * is already a Point, or an unknown type, return it unchanged\n * @param {Array<Number>|Point|*} a any kind of input value\n * @return {Point} constructed point, or passed-through value.\n * @example\n * // this\n * var point = Point.convert([0, 1]);\n * // is equivalent to\n * var point = new Point(0, 1);\n */\n\nPoint.convert = function (a) {\n  if (a instanceof Point) {\n    return a;\n  }\n\n  if (Array.isArray(a)) {\n    return new Point(a[0], a[1]);\n  }\n\n  return a;\n};","map":{"version":3,"names":["module","exports","Point","x","y","prototype","clone","add","p","_add","sub","_sub","multByPoint","_multByPoint","divByPoint","_divByPoint","mult","k","_mult","div","_div","rotate","a","_rotate","rotateAround","_rotateAround","matMult","m","_matMult","unit","_unit","perp","_perp","round","_round","mag","Math","sqrt","equals","other","dist","distSqr","dx","dy","angle","atan2","angleTo","b","angleWith","angleWithSep","cos","sin","convert","Array","isArray"],"sources":["/Users/nathanwang/Documents/LMC/escape-berlin/node_modules/@mapbox/point-geometry/index.js"],"sourcesContent":["'use strict';\n\nmodule.exports = Point;\n\n/**\n * A standalone point geometry with useful accessor, comparison, and\n * modification methods.\n *\n * @class Point\n * @param {Number} x the x-coordinate. this could be longitude or screen\n * pixels, or any other sort of unit.\n * @param {Number} y the y-coordinate. this could be latitude or screen\n * pixels, or any other sort of unit.\n * @example\n * var point = new Point(-77, 38);\n */\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype = {\n\n    /**\n     * Clone this point, returning a new point that can be modified\n     * without affecting the old one.\n     * @return {Point} the clone\n     */\n    clone: function() { return new Point(this.x, this.y); },\n\n    /**\n     * Add this point's x & y coordinates to another point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    add:     function(p) { return this.clone()._add(p); },\n\n    /**\n     * Subtract this point's x & y coordinates to from point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    sub:     function(p) { return this.clone()._sub(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    multByPoint:    function(p) { return this.clone()._multByPoint(p); },\n\n    /**\n     * Divide this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    divByPoint:     function(p) { return this.clone()._divByPoint(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {Point} k factor\n     * @return {Point} output point\n     */\n    mult:    function(k) { return this.clone()._mult(k); },\n\n    /**\n     * Divide this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {Point} k factor\n     * @return {Point} output point\n     */\n    div:     function(k) { return this.clone()._div(k); },\n\n    /**\n     * Rotate this point around the 0, 0 origin by an angle a,\n     * given in radians\n     * @param {Number} a angle to rotate around, in radians\n     * @return {Point} output point\n     */\n    rotate:  function(a) { return this.clone()._rotate(a); },\n\n    /**\n     * Rotate this point around p point by an angle a,\n     * given in radians\n     * @param {Number} a angle to rotate around, in radians\n     * @param {Point} p Point to rotate around\n     * @return {Point} output point\n     */\n    rotateAround:  function(a,p) { return this.clone()._rotateAround(a,p); },\n\n    /**\n     * Multiply this point by a 4x1 transformation matrix\n     * @param {Array<Number>} m transformation matrix\n     * @return {Point} output point\n     */\n    matMult: function(m) { return this.clone()._matMult(m); },\n\n    /**\n     * Calculate this point but as a unit vector from 0, 0, meaning\n     * that the distance from the resulting point to the 0, 0\n     * coordinate will be equal to 1 and the angle from the resulting\n     * point to the 0, 0 coordinate will be the same as before.\n     * @return {Point} unit vector point\n     */\n    unit:    function() { return this.clone()._unit(); },\n\n    /**\n     * Compute a perpendicular point, where the new y coordinate\n     * is the old x coordinate and the new x coordinate is the old y\n     * coordinate multiplied by -1\n     * @return {Point} perpendicular point\n     */\n    perp:    function() { return this.clone()._perp(); },\n\n    /**\n     * Return a version of this point with the x & y coordinates\n     * rounded to integers.\n     * @return {Point} rounded point\n     */\n    round:   function() { return this.clone()._round(); },\n\n    /**\n     * Return the magitude of this point: this is the Euclidean\n     * distance from the 0, 0 coordinate to this point's x and y\n     * coordinates.\n     * @return {Number} magnitude\n     */\n    mag: function() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n\n    /**\n     * Judge whether this point is equal to another point, returning\n     * true or false.\n     * @param {Point} other the other point\n     * @return {boolean} whether the points are equal\n     */\n    equals: function(other) {\n        return this.x === other.x &&\n               this.y === other.y;\n    },\n\n    /**\n     * Calculate the distance from this point to another point\n     * @param {Point} p the other point\n     * @return {Number} distance\n     */\n    dist: function(p) {\n        return Math.sqrt(this.distSqr(p));\n    },\n\n    /**\n     * Calculate the distance from this point to another point,\n     * without the square root step. Useful if you're comparing\n     * relative distances.\n     * @param {Point} p the other point\n     * @return {Number} distance\n     */\n    distSqr: function(p) {\n        var dx = p.x - this.x,\n            dy = p.y - this.y;\n        return dx * dx + dy * dy;\n    },\n\n    /**\n     * Get the angle from the 0, 0 coordinate to this point, in radians\n     * coordinates.\n     * @return {Number} angle\n     */\n    angle: function() {\n        return Math.atan2(this.y, this.x);\n    },\n\n    /**\n     * Get the angle from this point to another point, in radians\n     * @param {Point} b the other point\n     * @return {Number} angle\n     */\n    angleTo: function(b) {\n        return Math.atan2(this.y - b.y, this.x - b.x);\n    },\n\n    /**\n     * Get the angle between this point and another point, in radians\n     * @param {Point} b the other point\n     * @return {Number} angle\n     */\n    angleWith: function(b) {\n        return this.angleWithSep(b.x, b.y);\n    },\n\n    /*\n     * Find the angle of the two vectors, solving the formula for\n     * the cross product a x b = |a||b|sin(θ) for θ.\n     * @param {Number} x the x-coordinate\n     * @param {Number} y the y-coordinate\n     * @return {Number} the angle in radians\n     */\n    angleWithSep: function(x, y) {\n        return Math.atan2(\n            this.x * y - this.y * x,\n            this.x * x + this.y * y);\n    },\n\n    _matMult: function(m) {\n        var x = m[0] * this.x + m[1] * this.y,\n            y = m[2] * this.x + m[3] * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _add: function(p) {\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    },\n\n    _sub: function(p) {\n        this.x -= p.x;\n        this.y -= p.y;\n        return this;\n    },\n\n    _mult: function(k) {\n        this.x *= k;\n        this.y *= k;\n        return this;\n    },\n\n    _div: function(k) {\n        this.x /= k;\n        this.y /= k;\n        return this;\n    },\n\n    _multByPoint: function(p) {\n        this.x *= p.x;\n        this.y *= p.y;\n        return this;\n    },\n\n    _divByPoint: function(p) {\n        this.x /= p.x;\n        this.y /= p.y;\n        return this;\n    },\n\n    _unit: function() {\n        this._div(this.mag());\n        return this;\n    },\n\n    _perp: function() {\n        var y = this.y;\n        this.y = this.x;\n        this.x = -y;\n        return this;\n    },\n\n    _rotate: function(angle) {\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = cos * this.x - sin * this.y,\n            y = sin * this.x + cos * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _rotateAround: function(angle, p) {\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),\n            y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _round: function() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        return this;\n    }\n};\n\n/**\n * Construct a point from an array if necessary, otherwise if the input\n * is already a Point, or an unknown type, return it unchanged\n * @param {Array<Number>|Point|*} a any kind of input value\n * @return {Point} constructed point, or passed-through value.\n * @example\n * // this\n * var point = Point.convert([0, 1]);\n * // is equivalent to\n * var point = new Point(0, 1);\n */\nPoint.convert = function (a) {\n    if (a instanceof Point) {\n        return a;\n    }\n    if (Array.isArray(a)) {\n        return new Point(a[0], a[1]);\n    }\n    return a;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}